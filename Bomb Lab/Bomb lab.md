# Bomb lab

## 准备

熟悉GDB常用操作

- 查看寄存器  `print $rax`
- 打断点
- 查看某一段内存地址的值
- 查看寄存器对应的内存地址的值



## phase_1

将读入的字符串保存，和某一段内存地址上的字符串比较，如果相等就OK；

需要注意的是函数传参时寄存器的使用

- `$rdi`
- `$rsi`
- `$rdx`
- `$rcx`



## phase_2

是一个do-while的Loop pattern，每次数字都翻倍，第一个数字是1



## phase_3

是一个switch的pattern，先输入两个数字，一个是索引，后一个必须是switch里的对上，否则explode



##  phase_4

需要输入两个数字，第一个数字用来控制内部func4的返回值，第二个值做简单的if判断

func4有三个参数(x,y,z)，在开头先计算tmp = (z-y)>>1+y，然后将tmp和x比较，产生三个分支，有两个分支是递归。为了达到最终返回值是0的效果，对x，也就是我们最初输入的的一个数字有要求，必不可能进入第二个分支，为了不进入第二个分支，x只能是0，否则在内层某个递归时会返回大于0的值



## phase_5

内部主要结构是一个for-loop，需要输入6个字符，将字符做一些转换（一共8位，前四位变成0，后四位作为offset），索引某个给定的字符串，得到新的6个字符，存放在stack上，这六个字符需要是“flyers”，但是输入的可以有多个选择（大小写都行）



## phase_6

作为压轴题，code非常的长，需要切割成多个部分进行理解

首先input是六个数字，先是二层循环，确保6个数字是1-6之间的无重复排列；

其次将这六个数组进行转换b[i] = 7-a[i]（没啥特殊作用，只是将代码变得更复杂而已）

其次将这六个数字作为offset（需要乘以乘数），加上0x6032d0，存在\$rsp+32->​\$rsp+72这48个字节的栈上，可以认为是6个元素的8字节数组c,c[i] = 0x6032d0+(b[i]-1)*16

可以发现，c中6个元素的上下限分别是0x6032d0, 0x603320,每个元素之间有16个字节的空间，第一个8字节空间存放data，第二个8字节空间存放数组下一个元素的内容。举个例子，假设b[i] = {1,2,3,4,5,6}，那么stack中存放的是0x6032d0,0x6032e0,0x6032f0,,,,0x603320，那么在0x6032d8存放的是0x6032e0

此处假设b[i]元素对应内存地址+8处存放的6个数字一次构成d[i]

最后是对b[i]的顺序判断，要求d[i]是递增（减？），这就需要对那六个数字进行人为判断，反推出b[i]的顺序，最终得出a[i]



## 总结

作为第一个正式的Lab，最后两个part还是不简单的，整个过程中也学习了汇编语法的数据传输（data transfer）、control（跳转）、procedures（函数传参、返回、stack布局）、GDB的入门使用这些东西。



